name: Build & Deploy
on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write  # use GITHUB_TOKEN for GHCR

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.meta.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      # Lowercase repo for GHCR image name
      - name: Compute image tag
        run: echo "IMAGE=ghcr.io/${GITHUB_REPOSITORY,,}:${GITHUB_SHA}" >> $GITHUB_ENV

      - name: Log in to GHCR (GITHUB_TOKEN)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build image (inline NEXT_PUBLIC_* for client code)
        run: |
          docker build \
            --build-arg NEXT_PUBLIC_SUPABASE_URL="${{ secrets.SUPABASE_URL }}" \
            --build-arg NEXT_PUBLIC_SUPABASE_ANON_KEY="${{ secrets.SUPABASE_ANON_KEY }}" \
            -t "$IMAGE" .

      - name: Push image
        run: docker push "$IMAGE"

      - id: meta
        name: Export image ref
        run: echo "image=$IMAGE" >> $GITHUB_OUTPUT

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Write SSH key
        run: |
          echo "${{ secrets.VM_SSH_KEY }}" > key.pem
          chmod 600 key.pem

      - name: Deploy on VM
        run: |
          HOST="${{ secrets.VM_HOST }}"
          USER="${{ secrets.VM_USER }}"
          PORT="${{ secrets.VM_SSH_PORT || 22 }}"

          # Values from this job we need on the remote host
          IMAGE="${{ needs.build.outputs.image }}"
          ACTOR="${{ github.actor }}"
          TOKEN="${{ secrets.GITHUB_TOKEN }}"

          # Pass vars into remote env, keep heredoc single-quoted
          ssh -o StrictHostKeyChecking=no -i key.pem -p "$PORT" "$USER@$HOST" \
            "IMAGE='$IMAGE' ACTOR='$ACTOR' TOKEN='$TOKEN' bash -s" <<'SH'
          set -euxo pipefail

          sudo docker login ghcr.io -u "$ACTOR" -p "$TOKEN"
          sudo mkdir -p /opt/team-tasks
          cd /opt/team-tasks

          # Fresh .env (server + public)
          rm -f .env; touch .env
          [ -n '${{ secrets.SUPABASE_URL }}' ] && echo 'SUPABASE_URL=${{ secrets.SUPABASE_URL }}' | sudo tee -a .env >/dev/null || true
          [ -n '${{ secrets.SUPABASE_ANON_KEY }}' ] && echo 'SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}' | sudo tee -a .env >/dev/null || true
          echo 'NEXT_PUBLIC_SUPABASE_URL=${{ secrets.SUPABASE_URL }}' | sudo tee -a .env >/dev/null
          echo 'NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}' | sudo tee -a .env >/dev/null
          echo 'NODE_ENV=production' | sudo tee -a .env >/dev/null

          # Pull image
          sudo docker pull "$IMAGE"

          # Blue/green-lite on 8080
          sudo docker rm -f app_new || true
          sudo docker run -d --name app_new --restart unless-stopped \
            --env-file .env -p 8080:3000 "$IMAGE"

          # Health check
          ok=
          for i in {1..10}; do curl -fsS http://localhost:8080/api/healthz && ok=1 && break || sleep 2; done
          if [ -z "$ok" ]; then echo "Health check failed" >&2; sudo docker logs app_new || true; exit 1; fi

          # Free port 80 and swap
          sudo docker rm -f app || true
          sudo docker ps -q --filter "publish=80" | xargs -r sudo docker rm -f
          sudo docker run -d --name app --restart unless-stopped \
            --env-file .env -p 80:3000 "$IMAGE"

          # Clean staging
          sudo docker rm -f app_new || true
